import{r as c,j as p,t as S}from"./app-C2rmVmHv.js";function g(e,s){const t=c.createContext(s),i=r=>{const{children:n,...o}=r,l=c.useMemo(()=>o,Object.values(o));return p.jsx(t.Provider,{value:l,children:n})};i.displayName=e+"Provider";function u(r){const n=c.useContext(t);if(n)return n;if(s!==void 0)return s;throw new Error(`\`${r}\` must be used within \`${e}\``)}return[i,u]}function j(e,s=[]){let t=[];function i(r,n){const o=c.createContext(n),l=t.length;t=[...t,n];const d=f=>{const{scope:x,children:m,...v}=f,C=x?.[e]?.[l]||o,h=c.useMemo(()=>v,Object.values(v));return p.jsx(C.Provider,{value:h,children:m})};d.displayName=r+"Provider";function a(f,x){const m=x?.[e]?.[l]||o,v=c.useContext(m);if(v)return v;if(n!==void 0)return n;throw new Error(`\`${f}\` must be used within \`${r}\``)}return[d,a]}const u=()=>{const r=t.map(n=>c.createContext(n));return function(o){const l=o?.[e]||r;return c.useMemo(()=>({[`__scope${e}`]:{...o,[e]:l}}),[o,l])}};return u.scopeName=e,[i,b(u,...s)]}function b(...e){const s=e[0];if(e.length===1)return s;const t=()=>{const i=e.map(u=>({useScope:u(),scopeName:u.scopeName}));return function(r){const n=i.reduce((o,{useScope:l,scopeName:d})=>{const f=l(r)[`__scope${d}`];return{...o,...f}},{});return c.useMemo(()=>({[`__scope${s.scopeName}`]:n}),[n])}};return t.scopeName=s.scopeName,t}var w=globalThis?.document?c.useLayoutEffect:()=>{},E=S[" useInsertionEffect ".trim().toString()]||w;function _({prop:e,defaultProp:s,onChange:t=()=>{},caller:i}){const[u,r,n]=P({defaultProp:s,onChange:t}),o=e!==void 0,l=o?e:u;{const a=c.useRef(e!==void 0);c.useEffect(()=>{const f=a.current;f!==o&&console.warn(`${i} is changing from ${f?"controlled":"uncontrolled"} to ${o?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),a.current=o},[o,i])}const d=c.useCallback(a=>{if(o){const f=$(a)?a(e):a;f!==e&&n.current?.(f)}else r(a)},[o,e,r,n]);return[l,d]}function P({defaultProp:e,onChange:s}){const[t,i]=c.useState(e),u=c.useRef(t),r=c.useRef(s);return E(()=>{r.current=s},[s]),c.useEffect(()=>{u.current!==t&&(r.current?.(t),u.current=t)},[t,u]),[t,i,r]}function $(e){return typeof e=="function"}export{_ as a,g as b,j as c,w as u};
